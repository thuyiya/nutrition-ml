import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import copy
import math

class AdaptiveMealPlanner:
    """
    Adaptive meal planning system that adjusts meal plans based on logged meals
    and missed meals to ensure daily nutrition targets are met.
    """
    
    def __init__(self):
        self.meal_types_order = {
            'Breakfast': 1,
            'Morning Snack': 2,
            'Pre-Exercise Snack': 2,
            'Pre-Exercise Snack 1': 2,
            'Post-Exercise Meal': 3,
            'Post-Exercise Meal 1': 3,
            'Lunch': 4,
            'Afternoon Snack': 5,
            'Pre-Exercise Snack 2': 5,
            'Post-Exercise Meal 2': 6,
            'Recovery Snack': 7,
            'Dinner': 8,
            'Evening Meal': 8,
            'Evening Snack': 9
        }
        
        self.meal_weights = {
            'main_meal': 2.0,  # Breakfast, Lunch, Dinner
            'snack': 1.0       # All snacks
        }
    
    def adapt_meal_plan(self, original_meal_plan, meal_logging_data, current_time=None):
        """
        Adapt a meal plan based on logged meals and current time.
        
        Args:
            original_meal_plan: Original meal plan generated by the AI
            meal_logging_data: List of logged meals with consumption details
            current_time: Current time (defaults to now if not provided)
            
        Returns:
            Adapted meal plan with redistributed nutrition
        """
        if current_time is None:
            current_time = datetime.now()
        
        # Make a deep copy of the original meal plan to avoid modifying it
        adapted_plan = copy.deepcopy(original_meal_plan)
        
        # Extract meal plan and nutrition targets
        meals = adapted_plan['meal_plan']
        total_nutrition = adapted_plan['total_nutrition']
        
        # Analyze logged meals and missed meals
        analysis = self._analyze_meal_logging(meals, meal_logging_data, current_time)
        
        # If no missed meals or all meals consumed, return original plan
        if not analysis['missed_meals'] and not analysis['partial_meals']:
            adapted_plan['adaptation_status'] = 'no_adaptation_needed'
            return adapted_plan
        
        # Calculate nutrition deficit
        deficit = self._calculate_nutrition_deficit(analysis, total_nutrition)
        
        # Redistribute deficit to remaining meals
        adapted_meals = self._redistribute_nutrition(meals, analysis, deficit, current_time)
        
        # Update the meal plan
        adapted_plan['meal_plan'] = adapted_meals
        adapted_plan['adaptation_status'] = 'adapted'
        adapted_plan['adaptation_details'] = {
            'missed_meals': len(analysis['missed_meals']),
            'partial_meals': len(analysis['partial_meals']),
            'deficit': deficit,
            'adaptation_time': current_time.isoformat(),
            'adaptation_reason': self._get_adaptation_reason(analysis)
        }
        
        return adapted_plan
    
    def _analyze_meal_logging(self, meals, meal_logging_data, current_time):
        """
        Analyze logged meals to identify missed and partial meals.
        """
        analysis = {
            'logged_meals': [],
            'missed_meals': [],
            'partial_meals': [],
            'remaining_meals': [],
            'consumed_nutrition': {
                'calories': 0,
                'carbs_g': 0,
                'protein_g': 0,
                'fat_g': 0
            }
        }
        
        # Convert current time to datetime if it's a string
        if isinstance(current_time, str):
            try:
                current_time = datetime.fromisoformat(current_time.replace('Z', '+00:00'))
            except ValueError:
                current_time = datetime.now()
        
        # Ensure current_time is timezone-naive for comparison
        if hasattr(current_time, 'tzinfo') and current_time.tzinfo is not None:
            # Convert to naive datetime in local time
            current_time = datetime.now().replace(
                hour=current_time.hour,
                minute=current_time.minute,
                second=current_time.second
            )
        
        # Create a map of logged meals by type
        logged_meals_map = {}
        for logged_meal in meal_logging_data:
            meal_type = logged_meal.get('meal_type')
            if meal_type:
                logged_meals_map[meal_type] = logged_meal
                
                # Add to consumed nutrition
                analysis['consumed_nutrition']['calories'] += logged_meal.get('calories', 0)
                analysis['consumed_nutrition']['carbs_g'] += logged_meal.get('carbs_g', 0)
                analysis['consumed_nutrition']['protein_g'] += logged_meal.get('protein_g', 0)
                analysis['consumed_nutrition']['fat_g'] += logged_meal.get('fat_g', 0)
                
                # Check if it's a partial meal
                consumed_percentage = self._parse_consumed_percentage(logged_meal.get('consumed', '100%'))
                if consumed_percentage < 0.9:  # Less than 90% consumed
                    analysis['partial_meals'].append({
                        'meal_type': meal_type,
                        'consumed_percentage': consumed_percentage,
                        'logged_meal': logged_meal
                    })
                
                analysis['logged_meals'].append(logged_meal)
        
        # Check each meal in the plan
        for meal in meals:
            meal_type = meal['meal_type']
            meal_time = self._parse_time(meal['time'])
            
            # Convert meal time to datetime for comparison
            meal_datetime = datetime.combine(current_time.date(), meal_time)
            
            # Check if meal is missed (time has passed but not logged)
            if meal_datetime < current_time and meal_type not in logged_meals_map:
                analysis['missed_meals'].append(meal)
            
            # Check if meal is still upcoming
            if meal_datetime >= current_time:
                analysis['remaining_meals'].append(meal)
        
        return analysis
    
    def _calculate_nutrition_deficit(self, analysis, total_nutrition):
        """
        Calculate nutrition deficit from missed and partial meals.
        """
        deficit = {
            'calories': 0,
            'carbs_g': 0,
            'protein_g': 0,
            'fat_g': 0
        }
        
        # Add deficit from missed meals
        for meal in analysis['missed_meals']:
            deficit['calories'] += meal.get('calories', 0)
            deficit['carbs_g'] += meal.get('carbs_g', 0)
            deficit['protein_g'] += meal.get('protein_g', 0)
            deficit['fat_g'] += meal.get('fat_g', 0)
        
        # Add deficit from partial meals
        for partial in analysis['partial_meals']:
            logged_meal = partial['logged_meal']
            meal_type = partial['meal_type']
            consumed_percentage = partial['consumed_percentage']
            
            # Find the original meal in the plan
            original_meal = next((m for m in analysis['missed_meals'] + analysis['remaining_meals'] 
                                if m['meal_type'] == meal_type), None)
            
            if original_meal:
                deficit['calories'] += original_meal.get('calories', 0) * (1 - consumed_percentage)
                deficit['carbs_g'] += original_meal.get('carbs_g', 0) * (1 - consumed_percentage)
                deficit['protein_g'] += original_meal.get('protein_g', 0) * (1 - consumed_percentage)
                deficit['fat_g'] += original_meal.get('fat_g', 0) * (1 - consumed_percentage)
        
        return deficit
    
    def _redistribute_nutrition(self, meals, analysis, deficit, current_time):
        """
        Redistribute nutrition deficit to remaining meals.
        """
        # Get remaining meals
        remaining_meals = analysis['remaining_meals']
        
        # If no remaining meals, return original meals
        if not remaining_meals:
            return meals
        
        # Calculate total weight for distribution
        total_weight = sum(self._get_meal_weight(meal) for meal in remaining_meals)
        
        # Create adapted meals list
        adapted_meals = []
        
        for meal in meals:
            meal_type = meal['meal_type']
            meal_time = self._parse_time(meal['time'])
            meal_datetime = datetime.combine(current_time.date(), meal_time)
            
            # If meal is already past and logged, keep original
            if meal_datetime < current_time and meal_type in [m.get('meal_type') for m in analysis['logged_meals']]:
                adapted_meals.append(meal)
                continue
            
            # If meal is already past and not logged, mark as missed
            if meal_datetime < current_time:
                missed_meal = meal.copy()
                missed_meal['status'] = 'missed'
                adapted_meals.append(missed_meal)
                continue
            
            # For remaining meals, redistribute deficit
            if meal_datetime >= current_time:
                adapted_meal = meal.copy()
                meal_weight = self._get_meal_weight(meal)
                
                # Calculate this meal's share of the deficit
                share = meal_weight / total_weight if total_weight > 0 else 0
                
                # Apply safety cap (max 5% increase for main meals)
                max_increase_percentage = 0.05 if self._is_main_meal(meal) else 0.10
                
                # Calculate additional nutrition
                additional_calories = min(deficit['calories'] * share, 
                                         meal['calories'] * max_increase_percentage)
                additional_carbs = min(deficit['carbs_g'] * share, 
                                     meal['carbs_g'] * max_increase_percentage)
                additional_protein = min(deficit['protein_g'] * share, 
                                       meal['protein_g'] * max_increase_percentage)
                additional_fat = min(deficit['fat_g'] * share, 
                                   meal['fat_g'] * max_increase_percentage)
                
                # Update meal nutrition
                adapted_meal['calories'] = round(meal['calories'] + additional_calories, 1)
                adapted_meal['carbs_g'] = round(meal['carbs_g'] + additional_carbs, 1)
                adapted_meal['protein_g'] = round(meal['protein_g'] + additional_protein, 1)
                adapted_meal['fat_g'] = round(meal['fat_g'] + additional_fat, 1)
                adapted_meal['status'] = 'adapted'
                adapted_meal['adaptation_note'] = self._get_adaptation_note(meal, additional_calories)
                
                adapted_meals.append(adapted_meal)
        
        return adapted_meals
    
    def _get_meal_weight(self, meal):
        """
        Get weight for a meal to determine how much deficit it should absorb.
        """
        if self._is_main_meal(meal):
            return self.meal_weights['main_meal']
        else:
            return self.meal_weights['snack']
    
    def _is_main_meal(self, meal):
        """
        Check if a meal is a main meal (breakfast, lunch, dinner).
        """
        main_meals = ['Breakfast', 'Lunch', 'Dinner', 'Post-Exercise Meal', 
                     'Post-Exercise Meal 1', 'Post-Exercise Meal 2', 'Evening Meal']
        return meal['meal_type'] in main_meals
    
    def _parse_time(self, time_str):
        """
        Parse time string to datetime.time object.
        """
        try:
            return datetime.strptime(time_str, '%I:%M %p').time()
        except ValueError:
            try:
                return datetime.strptime(time_str, '%H:%M').time()
            except ValueError:
                # Default to noon if parsing fails
                return datetime.strptime('12:00', '%H:%M').time()
    
    def _parse_consumed_percentage(self, consumed_str):
        """
        Parse consumed percentage from string like '90%' or float like 0.9.
        """
        if isinstance(consumed_str, (int, float)):
            return float(consumed_str)
        
        if isinstance(consumed_str, str):
            try:
                # Try to parse percentage string like '90%'
                if consumed_str.endswith('%'):
                    return float(consumed_str.rstrip('%')) / 100
                # Try to parse decimal string like '0.9'
                else:
                    return float(consumed_str)
            except ValueError:
                pass
        
        # Default to 100% if parsing fails
        return 1.0
    
    def _get_adaptation_note(self, meal, additional_calories):
        """
        Generate adaptation note for a meal.
        """
        if additional_calories <= 0:
            return "No adaptation needed"
        
        percentage_increase = (additional_calories / meal['calories']) * 100 if meal['calories'] > 0 else 0
        
        if percentage_increase < 1:
            return "Slight increase to compensate for missed nutrition"
        elif percentage_increase < 3:
            return "Moderate increase to compensate for missed nutrition"
        else:
            return f"Increased by {percentage_increase:.1f}% to compensate for missed nutrition"
    
    def _get_adaptation_reason(self, analysis):
        """
        Generate reason for adaptation.
        """
        reasons = []
        
        if analysis['missed_meals']:
            missed_types = [meal['meal_type'] for meal in analysis['missed_meals']]
            reasons.append(f"Missed meals: {', '.join(missed_types)}")
        
        if analysis['partial_meals']:
            partial_types = [f"{p['meal_type']} ({p['consumed_percentage']*100:.0f}%)" 
                           for p in analysis['partial_meals']]
            reasons.append(f"Partially consumed: {', '.join(partial_types)}")
        
        if not reasons:
            return "Optimization based on current time"
        
        return "; ".join(reasons) 